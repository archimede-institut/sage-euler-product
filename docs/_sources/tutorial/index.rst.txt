.. _index:


Tutorial Euler Product
======================

Introduction and principles
---------------------------

The main object of this software is to compute in a very fast manner Euler products with rational local factors over primes in some collections of arithmetic progressions modulo some fixed modulus :math:`q`.
Here are two examples  :math:`E_1=\prod_{p\equiv 3,5[7]}(1-1/p^2)`, where the product is taken over every prime :math:`p` congruent to 3 or 5 modulo 7, and :math:`E_2 = \prod_{p\equiv 1[8]}\bigl(1-\frac{4}{p}\bigr)\bigl(\frac{p+1}{p-1}\bigr)^2`, the so-called Shanks's constant, where the product is taken over every prime congruent to 1 modulo 8.

Euler products over rational functions such as :math:`E_2` are inferred from simpler Euler products of the shape 

.. math::
   \prod_{p\in\mathcal{A}\mod q}(1-1/p^s),

where

 * :math:`\mathcal{A}` is some subset of :math:`G=(\mathbb{Z}/q\mathbb{Z})^\times`. The subset :math:`\mathcal{A}` has to be the union of "lattice invariant classes", as described below.
 * :math:`q` is a positive integer, the so-called "modulus". We have :math:`q=7` for :math:`E_1`.
 * :math:`s` is a real parameter that is strictly positif and \*in this example\* strictly larger than 1. A typical choice is :math:`s=2`.

In case :math:`q=1`, the notion of lattice invariant classes is trivial. Let us start by describing this case.

Euler Product over every primes
-------------------------------

.. code-block:: default
     
     from euler_product.lattice_invariant_euler_products import get_euler_products
     get_euler_products(1, 2.1 , 1-x^2, 1+x^3, 103, 20, verbose = 0, with_Latex = 0, digits_offset = 10)

This computes the Euler product :math:`\prod_{p\ge2}\frac{1-1/p^{2s}}{1+1/p^{3s}}` where :math:`s=2.1` with potentially 103 correct digits and by computing directly the Euler product for all the primes less than :math:`P=20`. This value of :math:`P` is 100 by default. The level of comments :code:`verbose` can be set to 0, 1 or 2. The additionnal parameter :code:`with_Latex` is either equal to 1 or not equal to 1, with an obvious meaning. If the output does not have enough correct digits, the user is asked to increase the value 103 to 110 for instance. We decided not to automate this behaviour.

The parameter :code:`digits_offset` is not used as of now.

On the effect of the choice of :math:`s`, notice that the two calls

.. code-block:: default
     
     get_euler_products(1, 1 , 1-x^4, 1, 103)
     get_euler_products(1, 2 , 1-x^2, 1, 103)

give the same answer, which is readily seen to be an approximation of :math:`1/\zeta(4)`, where :math:`zeta` is the Riemann-zeta function. Recall that we have :math:`\zeta(4)=\pi^4/90`, a fact that we may use to check our code.

Euler Product over primes in arithmetic progression
---------------------------------------------------


- Definition Lattice Invariant

We subdivide the multiplicative group :math:`G=(\mathbb{Z}/q\mathbb{Z})^\times` in classes called  `LatticeInvariantClasses`
When :math:`q = 15` these classes are obtained by

.. code-block:: default

       LatticeInvariant(15)[1]
       (frozenset({1}), frozenset({4}), frozenset({11}), frozenset({14}), frozenset({8, 2}), frozenset({13, 7}))


.. code-block:: default
     
        from euler_product.utils_euler_product import LatticeInvariant
        LatticeInvariant(15)
        ((frozenset({1}), frozenset({1, 4}), frozenset({1, 11}), frozenset({1, 14}), frozenset({8, 1, 2, 4}), frozenset({1, 4, 13, 7})), 
         (frozenset({1}), frozenset({4}), frozenset({11}), frozenset({14}), frozenset({8, 2}), frozenset({13, 7})))


Two points are in the same class if and only if they generate the same subgroup modulo :math:`q`

- Low level functions

.. code-block:: default

       from euler_product.utils_euler_product import ComponentStructure
       mystructure = ComponentStructure(3)

This class proposes several quantities. It is used by the high level function :code:`get_vs` and :code:`get_euler_products`, so the user does not have to worry about it. However the quantities computed may have interest.

 * :code:`mystructure.q`: the modulus :math:`q`.
 * :code:`mystructure.phi_q`: the value of the Euler phi-function at :math:`q`.
 * :code:`mystructure.the_exponent`: the exponent of the group :math:`G=(\mathbb{Z}/q\mathbb{Z})^\times`.
 * :code:`mystructure.invertibles`: the tuple of invertibles in :math:`(\mathbb{Z}/q\mathbb{Z})`, i.e. an enumeration of :math:`G=(\mathbb{Z}/q\mathbb{Z})^\times`.
 * :code:`mystructure.the_SG_tuple`: the tuple of the subgroups of :math:`G=(\mathbb{Z}/q\mathbb{Z})^\times` that are generated by a single elements.
 * :code:`mystructure.the_Class_tuple`: the tuple of the lattice invariant classes.
 * :code:`mystructure.nb_class`: the number of lattice invariant classes.
 * :code:`mystructure.character_group`: the character group of :math:`G=(\mathbb{Z}/q\mathbb{Z})^\times`.
 * :code:`mystructure.invariant_characters`: for each monogenic subgroup in :code:`mystructure.the_SG_tuple`, the list of (the indices of) the characters that has this subgroup in its kernel. The order of :code:`mystructure.invariant_characters` is the same as the one in :code:`mystructure.the_SG_tuple`.

Some methods are also available.


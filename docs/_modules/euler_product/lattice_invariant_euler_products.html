<!doctype html>
<html class="no-js" lang="en" data-content_root="../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 7.2.6 and Furo 2024.01.29 -->
        <title>euler_product.lattice_invariant_euler_products - sage-euler-product 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?v=36a5483c" />
    <link rel="stylesheet" type="text/css" href="https://doc.sagemath.org/html/en/reference/_static/custom-furo.css" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  --color-brand-primary: #0f0fff;
  --color-brand-content: #0f0fff;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #272822;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">sage-euler-product 0.0.1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  <div class="sidebar-logo-container">
    <img class="sidebar-logo only-light" src="../../_static/nntdm-small.jpg" alt="Light Logo"/>
    <img class="sidebar-logo only-dark" src="../../_static/nntdm-small.jpg" alt="Dark Logo"/>
  </div>
  
  <span class="sidebar-brand-text">sage-euler-product 0.0.1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/index.html">Tutorial Euler Product</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/install_dev.html">Installation EULER_PRODUCT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/LoeschianConstant-NS-04-MCOMP.html">Fast multi-precision computation of some Euler products</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/api.html">API Documentation</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for euler_product.lattice_invariant_euler_products</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Lattice Invariant</span>

<span class="sd">lattice_invariant_euler_product.py defines the class ComponentStructure.</span>
<span class="sd">Computing with interval arithmetic and with a proven precision</span>
<span class="sd">Euler products of rational functions over primes in special sets modulo some fixed q.</span>
<span class="sd">These special sets are the lattice invariant classes modulo q, and the software also enables</span>
<span class="sd">the user to use them through the class ComponentStructure.</span>


<span class="sd">AUTHORS:</span>

<span class="sd">- Olivier Ramaré (2023-01-008) : initial version</span>
<span class="sd">- Dominique Benielli (2023-02_15) :</span>
<span class="sd">  Aix Marseille Université ,</span>
<span class="sd">  Integration as SageMath package.</span>
<span class="sd">  Cellule de developpement Institut Archimède</span>

<span class="sd">...WARNING:</span>

<span class="sd">  Needs Sage version at least 9.0</span>
<span class="sd">  CAREFUL, this is Python 3 code!</span>

<span class="sd">EXAMPLES::</span>

<span class="sd">    sage: from euler_product.lattice_invariant_euler_products import get_euler_products</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># *****************************************************************************</span>
<span class="c1">#       Copyright (C) 2023 Olivier Ramare</span>
<span class="c1">#       &lt; olivier . ramare @univ-amu.fr&gt;</span>
<span class="c1">#</span>
<span class="c1">#  Distributed under the terms of the GNU General Public License (GPL)</span>
<span class="c1">#                  http://www.gnu.org/licenses/</span>
<span class="c1"># *****************************************************************************</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">timeit</span> <span class="kn">import</span> <span class="n">default_timer</span> <span class="k">as</span> <span class="n">timer</span>

<span class="kn">from</span> <span class="nn">sage.functions.other</span> <span class="kn">import</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">floor</span>
<span class="kn">from</span> <span class="nn">sage.sets.primes</span> <span class="kn">import</span> <span class="n">Primes</span>
<span class="kn">from</span> <span class="nn">sage.modules.free_module_element</span> <span class="kn">import</span> <span class="n">vector</span>
<span class="kn">from</span> <span class="nn">sage.functions.log</span> <span class="kn">import</span> <span class="n">exp</span>
<span class="kn">from</span> <span class="nn">sage.functions.log</span> <span class="kn">import</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">sage.misc.misc_c</span> <span class="kn">import</span> <span class="n">prod</span>
<span class="kn">from</span> <span class="nn">sage.misc.flatten</span> <span class="kn">import</span> <span class="n">flatten</span>
<span class="kn">from</span> <span class="nn">sage.arith.misc</span> <span class="kn">import</span> <span class="n">prime_factors</span>
<span class="kn">from</span> <span class="nn">sage.arith.misc</span> <span class="kn">import</span> <span class="n">prime_divisors</span>
<span class="kn">from</span> <span class="nn">sage.rings.integer</span> <span class="kn">import</span> <span class="n">Integer</span>
<span class="kn">from</span> <span class="nn">sage.rings.real_mpfi</span> <span class="kn">import</span> <span class="n">RealIntervalField</span>
<span class="kn">from</span> <span class="nn">sage.rings.real_mpfr</span> <span class="kn">import</span> <span class="n">RealField</span>
<span class="kn">from</span> <span class="nn">euler_product.utils_euler_product</span> <span class="kn">import</span> <span class="n">ComponentStructure</span>
<span class="kn">from</span> <span class="nn">euler_product.utils_euler_product</span> <span class="kn">import</span> <span class="n">get_beta</span>
<span class="kn">from</span> <span class="nn">euler_product.utils_euler_product</span> <span class="kn">import</span> <span class="n">laTeX_for_number</span>
<span class="kn">from</span> <span class="nn">euler_product.utils_euler_product</span> <span class="kn">import</span> <span class="n">nb_common_digits</span>


<div class="viewcode-block" id="get_vs">
<a class="viewcode-back" href="../../reference/api.html#euler_product.lattice_invariant_euler_products.get_vs">[docs]</a>
<span class="k">def</span> <span class="nf">get_vs</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">nb_decimals</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">big_p</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">with_laTeX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">digits_offset</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the pair ((A), (approx_zeta(s; q, A))) where (A) is the tuple</span>
<span class="sd">    of the lattice-invariant classes modulo q</span>
<span class="sd">    and approx_zeta(s; q, A) is an arithmetic interval approximation</span>
<span class="sd">    of zeta(s; q; A) given in the form of a pair (lower_bound, upper_bound).</span>
<span class="sd">    We expect the difference upper_bound -  lower bound to be &lt; 10^(-nb_decimals)</span>
<span class="sd">    but this is not guaranteed. In case it does not happen, increase nb_decimals slightly.</span>
<span class="sd">    We compute directly what happens for primes &lt; big_p.</span>
<span class="sd">    Main Engines GetVs(12, 2, 100, 110)</span>

<span class="sd">    - ``q`` -- int</span>
<span class="sd">        The products are taken over classes modulo q</span>

<span class="sd">    - ``s`` -- real</span>
<span class="sd">        A real number &gt; 1</span>

<span class="sd">    - ``nb_decimals`` -- [type]</span>
<span class="sd">        The number of decimals that are being sought by the final result, by default 100.</span>
<span class="sd">        The function aims at such a number of decimals but a final tuning may be required</span>

<span class="sd">    - ``big_p`` -- int, optional</span>
<span class="sd">        This is an internal parameter that is described in the accompanying paper, by default 100.</span>
<span class="sd">        In short: the Euler products up to big_p are computed directly</span>

<span class="sd">    - ``verbose`` -- int, optional</span>
<span class="sd">        Defines the amount of output shown, by default 2.</span>
<span class="sd">        It may take the usual values 0, 1, 2, towards more explanations.</span>
<span class="sd">        When get_vs is used inside another function, verbose = 0 is usually what is required.</span>
<span class="sd">        The value -1 is special and the effect is fully described in the tutorial</span>

<span class="sd">    - ``with_laTeX`` -- int, optional</span>
<span class="sd">        This parameter takes the value 1 or not 1, by default 0.</span>
<span class="sd">        As of now, this has effect only when verbose = 2</span>

<span class="sd">    - ``digits_offset`` : int, optional</span>
<span class="sd">        Not used yet, by default 10</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    pair of tuples</span>
<span class="sd">        The output is a pair whose first component is the tuple of lattice invariant classes (A)</span>
<span class="sd">        and second component is the corresponding tuple of values (zeta(s; q, A)) where</span>
<span class="sd">        each value is given in interval arithmetic as a pair (lower_bound, upper_bound)</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from euler_product.lattice_invariant_euler_products import get_vs</span>
<span class="sd">        sage: get_vs(8, 3, 100)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        Computing the structural invariants ...  done.</span>
<span class="sd">        Computing big m ... Computing the finite product for p &lt; 100 ...  done.</span>
<span class="sd">        done: we use big_m = 18 .</span>
<span class="sd">        Building indices ... done: there are 5 summands.</span>
<span class="sd">        -------------------</span>
<span class="sd">        For p + 8ZZ in frozenset({1})</span>
<span class="sd">        the product of 1 / (1 - p^{-3}) is between</span>
<span class="sd">        1.00022487189858709876213790850059727367160406698000012383809358224349804195751158838756078343541771445946357</span>
<span class="sd">        and</span>
<span class="sd">        1.00022487189858709876213790850059727367160406698000012383809358224349804195751158838756078343541771445946376</span>
<span class="sd">        (Obtained:  105  correct decimal digits)</span>
<span class="sd">        -------------------</span>
<span class="sd">        For p + 8ZZ in frozenset({3})</span>
<span class="sd">        the product of 1 / (1 - p^{-3}) is between</span>
<span class="sd">        1.03941995442465275247765320826895776436688562576128093245373042938586210850475647986883816951846918262944993</span>
<span class="sd">        and</span>
<span class="sd">        1.03941995442465275247765320826895776436688562576128093245373042938586210850475647986883816951846918262945008</span>
<span class="sd">        (Obtained:  103  correct decimal digits)</span>
<span class="sd">        -------------------</span>
<span class="sd">        For p + 8ZZ in frozenset({5})</span>
<span class="sd">        the product of 1 / (1 - p^{-3}) is between</span>
<span class="sd">        1.00859929667035271781603021669885964068116773568938335524379250743431508655959698706547733008351071600945961</span>
<span class="sd">        and</span>
<span class="sd">        1.00859929667035271781603021669885964068116773568938335524379250743431508655959698706547733008351071600945975</span>
<span class="sd">        (Obtained:  105  correct decimal digits)</span>
<span class="sd">        -------------------</span>
<span class="sd">        For p + 8ZZ in frozenset({7})</span>
<span class="sd">        the product of 1 / (1 - p^{-3}) is between</span>
<span class="sd">        1.00305724526111080016727462667660715366818826631992203857221002140263476460120525161534802433614351034528702</span>
<span class="sd">        and</span>
<span class="sd">        1.00305724526111080016727462667660715366818826631992203857221002140263476460120525161534802433614351034528716</span>
<span class="sd">        (Obtained:  105  correct decimal digits)</span>
<span class="sd">        ((frozenset({1}), frozenset({3}), frozenset({5}), frozenset({7})),</span>
<span class="sd">        ((1.00022487189858709876213790850059727367160406698000012383809358224349804195751158838756078343541771445946357,</span>
<span class="sd">        1.00022487189858709876213790850059727367160406698000012383809358224349804195751158838756078343541771445946376),</span>
<span class="sd">        (1.03941995442465275247765320826895776436688562576128093245373042938586210850475647986883816951846918262944993,</span>
<span class="sd">        1.03941995442465275247765320826895776436688562576128093245373042938586210850475647986883816951846918262945008),</span>
<span class="sd">        (1.00859929667035271781603021669885964068116773568938335524379250743431508655959698706547733008351071600945961,</span>
<span class="sd">        1.00859929667035271781603021669885964068116773568938335524379250743431508655959698706547733008351071600945975),</span>
<span class="sd">        (1.00305724526111080016727462667660715366818826631992203857221002140263476460120525161534802433614351034528702,</span>
<span class="sd">        1.00305724526111080016727462667660715366818826631992203857221002140263476460120525161534802433614351034528716)))</span>

<span class="sd">    TESTS::</span>

<span class="sd">        sage: from euler_product.lattice_invariant_euler_products import get_vs</span>
<span class="sd">        sage: get_vs(3, 2, 100)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        Computing the structural invariants ...  done.</span>
<span class="sd">        Computing big m ... Computing the finite product for p &lt; 100 ...  done.</span>
<span class="sd">        done: we use big_m = 26 .</span>
<span class="sd">        Building indices ... done: there are 5 summands.</span>
<span class="sd">        -------------------</span>
<span class="sd">        For p + 3ZZ in frozenset({1})</span>
<span class="sd">        the product of 1 / (1 - p^{-2}) is between</span>
<span class="sd">        1.0340148754143419320638106705570396486453374255831232525075298255694199276378060505897424942813455074335751973</span>
<span class="sd">        and</span>
<span class="sd">        1.0340148754143419320638106705570396486453374255831232525075298255694199276378060505897424942813455074339378982</span>
<span class="sd">        (Obtained:  102  correct decimal digits)</span>
<span class="sd">        -------------------</span>
<span class="sd">        For p + 3ZZ in frozenset({2})</span>
<span class="sd">        the product of 1 / (1 - p^{-2}) is between</span>
<span class="sd">        1.4140643908921476331550630214976156797842162182076210188344144236787603450318717260556105084185151252818405878</span>
<span class="sd">        and</span>
<span class="sd">        1.4140643908921476331550630214976156797842162182076210188344144236787603450318717260556105084185151252823365985</span>
<span class="sd">        (Obtained:  101  correct decimal digits)</span>
<span class="sd">        ((frozenset({1}), frozenset({2})),</span>
<span class="sd">         ((1.0340148754143419320638106705570396486453374255831232525075298255694199276378060505897424942813455074335751973,</span>
<span class="sd">           1.0340148754143419320638106705570396486453374255831232525075298255694199276378060505897424942813455074339378982),</span>
<span class="sd">         (1.4140643908921476331550630214976156797842162182076210188344144236787603450318717260556105084185151252818405878,</span>
<span class="sd">           1.4140643908921476331550630214976156797842162182076210188344144236787603450318717260556105084185151252823365985)))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="c1">#  Compute the structural invariants:</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Computing the structural invariants ... &quot;</span><span class="p">)</span>

    <span class="n">structure</span> <span class="o">=</span> <span class="n">ComponentStructure</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="c1"># (theSGTuple, theClassTuple, nb_classes, theExponent,</span>
    <span class="c1"># phi_q, characterGroup, invertibles, invariantCharacters) = structure</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done.&quot;</span><span class="p">)</span>

    <span class="c1">#  Getting bigM:</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Computing big m ... &quot;</span><span class="p">)</span>

    <span class="n">allowed_primes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">prime_factors</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">phi_q</span><span class="p">))</span>
    <span class="n">cte</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span> <span class="o">*</span> <span class="n">prod</span><span class="p">([</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">allowed_primes</span><span class="p">])</span>
    <span class="n">big_m</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">cte</span><span class="p">)</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">big_p</span> <span class="o">/</span> <span class="p">(</span><span class="n">big_m</span> <span class="o">*</span> <span class="n">s</span><span class="p">))</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">big_m</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">big_p</span><span class="p">)</span>
                 <span class="o">+</span> <span class="p">(</span><span class="n">nb_decimals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">big_m</span> <span class="o">=</span> <span class="n">big_m</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1">#  Initial computations:</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Computing the finite product for p &lt; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">big_p</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; ... &quot;</span><span class="p">)</span>

    <span class="n">prec</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">nb_decimals</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">ceil</span><span class="p">(</span><span class="n">big_m</span><span class="p">))</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">RealIntervalField</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
    <span class="c1">#  Empty initial products are allowed:</span>
    <span class="n">euler_prod_ini</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">R</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">prod</span><span class="p">(</span>
        <span class="n">flatten</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">R</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">p</span><span class="o">**</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span> <span class="ow">in</span> <span class="n">Primes</span><span class="p">())</span>
                <span class="ow">and</span> <span class="p">(</span><span class="n">w</span> <span class="o">%</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">the_Class_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">big_p</span><span class="p">))]])))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done.&quot;</span><span class="p">)</span>
    <span class="n">log_err</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">cte</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">big_p</span> <span class="o">/</span> <span class="p">(</span><span class="n">big_m</span> <span class="o">*</span> <span class="n">s</span><span class="p">))</span> <span class="o">/</span> <span class="n">big_p</span><span class="o">**</span><span class="p">(</span><span class="n">s</span> <span class="o">*</span> <span class="n">big_m</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done: we use big_m =&quot;</span><span class="p">,</span> <span class="n">big_m</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>

    <span class="c1">#  Build the set of indices di:</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Building indices ... &quot;</span><span class="p">)</span>

    <span class="n">my_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span>
                                    <span class="nb">set</span><span class="p">(</span><span class="n">prime_factors</span><span class="p">(</span><span class="n">w</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">allowed_primes</span><span class="p">),</span>
                                    <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">big_m</span><span class="p">))]</span>
    <span class="c1">#  1 is indeed in my_indices.</span>
    <span class="n">CAKm</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_CA_Km</span><span class="p">(</span><span class="n">my_indices</span><span class="o">=</span><span class="n">my_indices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done: there are&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_indices</span><span class="p">),</span> <span class="s2">&quot;summands.&quot;</span><span class="p">)</span>
    <span class="n">vs_approx</span> <span class="o">=</span> <span class="p">[</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">my_indices</span><span class="p">:</span>
        <span class="c1"># print(q, m, s, bigP, prec)|-|</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">big_p</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind_a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ind_k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">):</span>
                <span class="n">vs_approx</span><span class="p">[</span><span class="n">ind_a</span><span class="p">]</span> <span class="o">+=</span> <span class="n">aux</span><span class="p">[</span><span class="n">ind_k</span><span class="p">]</span> <span class="o">*</span> <span class="n">CAKm</span><span class="p">[</span><span class="n">ind_a</span><span class="p">,</span> <span class="n">ind_k</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span>
    <span class="c1">#  We now have to get the Euler products:</span>
    <span class="n">eulerProds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([(</span><span class="n">R</span><span class="p">(</span><span class="n">euler_prod_ini</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">vs_approx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_err</span><span class="p">))</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                       <span class="n">R</span><span class="p">(</span><span class="n">euler_prod_ini</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">vs_approx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">log_err</span><span class="p">))</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">)])</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">):</span>
            <span class="n">nb_digits</span> <span class="o">=</span> <span class="n">nb_common_digits</span><span class="p">(</span><span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-------------------&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;For p + &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;ZZ in&quot;</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">the_Class_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;the product of 1 / (1 - p^{-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}) is between&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;and&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
            <span class="k">if</span> <span class="n">with_laTeX</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LaTeX format:&quot;</span><span class="p">)</span>
                <span class="n">how_many</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nb_decimals</span><span class="p">,</span> <span class="n">nb_digits</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">laTeX_for_number</span><span class="p">(</span><span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">how_many</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;(Obtained: &quot;</span><span class="p">,</span> <span class="n">nb_digits</span><span class="p">,</span> <span class="s2">&quot; correct decimal digits)&quot;</span><span class="p">)</span>

    <span class="n">end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time taken:&quot;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot;seconds.&quot;</span><span class="p">)</span>
    <span class="c1"># print(my_indices)</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span><span class="p">([</span><span class="n">big_p</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">phi_q</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_indices</span><span class="p">),</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">,</span> <span class="n">big_m</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
                <span class="o">-</span> <span class="n">floor</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">eulerProds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">eulerProds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))])</span>  <span class="c1"># type: ignore</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">structure</span><span class="o">.</span><span class="n">the_Class_tuple</span><span class="p">,</span> <span class="n">eulerProds</span></div>



<div class="viewcode-block" id="get_euler_products">
<a class="viewcode-back" href="../../reference/api.html#euler_product.lattice_invariant_euler_products.get_euler_products">[docs]</a>
<span class="k">def</span> <span class="nf">get_euler_products</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">f_init</span><span class="p">,</span> <span class="n">h_init</span><span class="p">,</span> <span class="n">nb_decimals</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">big_p</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">verbose</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">with_laTeX</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">digital_offset</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the pair ((A), (approx_prod_(p in A mod q) f_init(1/p^s) / h_init(1/ps) ) )</span>
<span class="sd">    where (A) is the tuple of the lattice-invariant classes modulo q</span>
<span class="sd">    and approx_prod_(p in A mod q) f_init(1/p^s) / h_init(1/ps) ) is an arithmetic interval approximation</span>
<span class="sd">    of the product over every prime in the class A modulo q of the quotient</span>
<span class="sd">    f_init(1/p^s) / h_init(1/p^s) given in the form of a pair (lower_bound, upper_bound).</span>
<span class="sd">    We expect the difference upper_bound -  lower bound to be &lt; 10^(-nb_decimals)</span>
<span class="sd">    but this is not guaranteed. In case it does not happen, increase nb_decimals slightly.</span>
<span class="sd">    We compute directly what happens for primes &lt; big_p.</span>
<span class="sd">    We assume that f_init(0) = h_init(0) = 1, that s is a positive real number</span>
<span class="sd">    and that Delta s &gt; 1 where Delta is the order of the zero of f_init-h_init at 0.</span>
<span class="sd">    This last condition is to ensure the Euler products converge absolutely</span>

<span class="sd">    to do</span>

<span class="sd">    assert F[0] = H[0] = 1</span>

<span class="sd">    GetEulerProds(3, 1, 1-x^2, 1, 100)</span>
<span class="sd">    (q, s, Finit, Hinit, nbdecimals, bigP= 00, Verbose=2, WithLaTeX=0)</span>
<span class="sd">    (q, s, F, H, nbdecimals, bigP = 100, Verbose = 2, WithLaTeX = 0)</span>


<span class="sd">    INPUT:</span>

<span class="sd">    - ``q`` -- int</span>
<span class="sd">        The products are taken over classes modulo q</span>

<span class="sd">    - ``s`` -- real</span>
<span class="sd">        A real number &gt; 0.</span>
<span class="sd">        Additional conditions may be required for the Euler products to be absolutely convergent</span>

<span class="sd">    - ``f_init`` -- pol</span>
<span class="sd">        A polynomial with real coefficients and such that f_init(0) = 1</span>

<span class="sd">    - ``h_init`` -- pol</span>
<span class="sd">        A polynomial with real coefficients and such that h_init(0) = 1</span>

<span class="sd">    - ``nb_decimals`` -- [type]</span>
<span class="sd">        The number of decimals that are being sought by the final result, by default 100.</span>
<span class="sd">        The function aims at such a number of decimals but a final tuning may be required</span>

<span class="sd">    - ``big_p`` -- int, optional</span>
<span class="sd">        This is an internal parameter that is described in the accompanying paper, by default 100.</span>
<span class="sd">        In short: the Euler products up to big_p are computed directly</span>

<span class="sd">    - ``verbose`` -- int, optional</span>
<span class="sd">        Defines the amount of output shown, by default 2.</span>
<span class="sd">        It may take the usual values 0, 1, 2, towards more explanations.</span>
<span class="sd">        When get_vs is used inside another function, verbose = 0 is usually what is required.</span>
<span class="sd">        The value -1 is special and the effect is fully described in the tutorial</span>

<span class="sd">    - ``with_laTeX`` -- int, optional</span>
<span class="sd">        This parameter takes the value 1 or not 1, by default 0.</span>
<span class="sd">        As of now, this has effect only when verbose = 2</span>

<span class="sd">    - ``digits_offset`` : int, optional</span>
<span class="sd">        Not used yet, by default 10</span>

<span class="sd">    OUTPUT:</span>

<span class="sd">    pair of tuples</span>
<span class="sd">        The output is a pair whose first component is the tuple of lattice invariant classes (A)</span>
<span class="sd">        and second component is the corresponding tuple of values</span>
<span class="sd">        (prod_(p in A mod q) f_init(1/p^s) / h_init(1/p^s) ) where</span>
<span class="sd">        each value is given in interval arithmetic as a pair (lower_bound, upper_bound)</span>

<span class="sd">    EXCEPTIONS:</span>
<span class="sd">        ValueError   (&#39;non convergent product&#39;)</span>
<span class="sd">        ValueError(&quot;f_init[0] and h_init[0] must be equal to 1&quot;)</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from euler_product.lattice_invariant_euler_products import get_euler_products</span>
<span class="sd">        sage: get_euler_products(3, 1, 1-x^2, 1, 100, verbose=0)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        ((frozenset({1}), frozenset({2})),</span>
<span class="sd">        ((0.9671040753637981066150556834173635260473412207450092130719978569438733967843271277395717230016746853806050215621235810749643636399725665325875376146914709362753787689855429317947529895445140974345,</span>
<span class="sd">        0.9671040753637981066150556834173635260473412207450092130719978569438733967843271277395717230016746853806050215621235810749643636399725665325875376146914709362753787689855429317947529895445140974477),</span>
<span class="sd">        (0.7071813747951674302088659938984504109243584468119496848353517677901518159831128643782536704398941052120208041311403202957250160794697319584608281454011743387515885835706146696365506658500107821105,</span>
<span class="sd">        0.7071813747951674302088659938984504109243584468119496848353517677901518159831128643782536704398941052120208041311403202957250160794697319584608281454011743387515885835706146696365506658500107821228)))</span>
<span class="sd">        sage: get_euler_products(8, 1, 1-2*x-7*x^2-4*x^3, 1-2*x+x^2, 110, 50, 0, 0)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        ((frozenset({1}), frozenset({3}), frozenset({5}), frozenset({7})),</span>
<span class="sd">        ((0.95694534785160118343696705727389182875317497729139147890543260424601701644488885948144051203907950843120693625020812276103159906625162986027780621959661661058242880638494733,</span>
<span class="sd">        0.95694534785160118343696705727389182875317497729139147890543260424601701644488885948144051203907950843120698715116910955482476415178562075800144085574035025387260631491020912),</span>
<span class="sd">        (-1.1744975454490034177155999666151209160615842743206296883125115013500947685793723674107330894468690657084850070249226110372932226333018435422450675119284554631204742715594780,</span>
<span class="sd">        -1.1744975454490034177155999666151209160615842743206296883125115013500947685793723674107330894468690657084850694977072727918933849576550337569751438204088603874573384648809813),</span>
<span class="sd">        (0.41303522430115813462933064104403132614973953141027630692477294245200590806656802414019031361757979375573715775187373750238649707664458852273214341861159234461302771883822062,</span>
<span class="sd">        0.41303522430115813462933064104403132614973953141027630692477294245200590806656802414019031361757979375573717972166689137936668012188844661293239520403935555328934054712625207),</span>
<span class="sd">        (0.73440531676250743047848787987972815324702590578219161532691471695315326661191699963756307237940693554033848218351377181727690073086294638978098135674230697193936653008013195,</span>
<span class="sd">        0.73440531676250743047848787987972815324702590578219161532691471695315326661191699963756307237940693554033852124733175620467822747169360181588443153429051853637559530089233888)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="c1"># assert F[0] = H[0] = 1</span>
    <span class="c1">#  Compute the structural invariants:</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Computing the structural invariants ... &quot;</span><span class="p">)</span>

    <span class="n">structure</span> <span class="o">=</span> <span class="n">ComponentStructure</span><span class="p">(</span><span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>
    <span class="c1">#  (theSGTuple, theClassTuple, nb_classes, theExponent,</span>
    <span class="c1">#  phi_q, characterGroup, invertibles, invariantCharacters) = structure</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done.&quot;</span><span class="p">)</span>

    <span class="c1">#  A small precision is enough:</span>
    <span class="n">R0</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">R0X</span> <span class="o">=</span> <span class="n">R0</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="o">=</span> <span class="n">R0X</span><span class="o">.</span><span class="n">_first_ngens</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">F0</span><span class="p">,</span> <span class="n">H0</span> <span class="o">=</span> <span class="n">R0X</span><span class="p">(</span><span class="n">f_init</span><span class="p">),</span> <span class="n">R0X</span><span class="p">(</span><span class="n">h_init</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Integer</span><span class="p">(</span><span class="n">H0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">Integer</span><span class="p">(</span><span class="n">F0</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;f_init[0] and h_init[0] must be equal to 1&quot;</span><span class="p">)</span>
    <span class="n">my_delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">F0</span> <span class="o">-</span> <span class="n">H0</span><span class="p">)</span><span class="o">.</span><span class="n">valuation</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">my_delta</span> <span class="o">*</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;non convergent product&#39;</span><span class="p">)</span>
    <span class="c1">#  Get my_beta, myDelta and big_p:</span>
    <span class="n">my_beta</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">get_beta</span><span class="p">(</span><span class="n">F0</span> <span class="o">/</span> <span class="n">F0</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">get_beta</span><span class="p">(</span><span class="n">H0</span> <span class="o">/</span> <span class="n">H0</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We have Delta =&quot;</span><span class="p">,</span> <span class="n">my_delta</span><span class="p">,</span> <span class="s2">&quot;and beta =&quot;</span><span class="p">,</span> <span class="n">my_beta</span><span class="p">)</span>

    <span class="c1">#  Getting bigM, prec and bigP:</span>
    <span class="n">big_p</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">big_p</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">my_beta</span><span class="p">)</span>
    <span class="n">cte</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">F0</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="o">+</span> <span class="n">H0</span><span class="o">.</span><span class="n">degree</span><span class="p">())</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">big_p</span><span class="p">)</span>
    <span class="n">big_m</span> <span class="o">=</span> <span class="n">big_p</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">cte</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">big_m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">big_p</span><span class="o">**</span><span class="n">s</span> <span class="o">/</span> <span class="n">my_beta</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">nb_decimals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">big_m</span> <span class="o">=</span> <span class="n">big_m</span> <span class="o">+</span> <span class="mi">10</span>

    <span class="c1">#  The coefficients CA(K,m,F/H) may increase like beta^m,</span>
    <span class="c1">#  This spoils the accuracy and has to be recovered:</span>
    <span class="n">prec</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">nb_decimals</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">ceil</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">big_m</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">my_beta</span><span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We use big_m =&quot;</span><span class="p">,</span> <span class="n">big_m</span><span class="p">,</span> <span class="s2">&quot;, big_p =&quot;</span><span class="p">,</span> <span class="n">big_p</span><span class="p">,</span> <span class="s2">&quot;and working prec =&quot;</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
    <span class="c1">#  The precision has changed! Change the ring:</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">RealIntervalField</span><span class="p">(</span><span class="n">prec</span><span class="p">)</span>
    <span class="n">RF</span> <span class="o">=</span> <span class="n">RealField</span><span class="p">(</span><span class="n">prec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">log_err</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="n">cte</span> <span class="o">*</span> <span class="p">(</span><span class="n">my_beta</span> <span class="o">/</span> <span class="p">(</span><span class="n">big_p</span><span class="o">**</span><span class="n">s</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="n">big_m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">RX</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="o">=</span> <span class="n">RX</span><span class="o">.</span><span class="n">_first_ngens</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">F</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">RX</span><span class="p">(</span><span class="n">f_init</span> <span class="o">/</span> <span class="n">Integer</span><span class="p">(</span><span class="n">F0</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">RX</span><span class="p">(</span><span class="n">h_init</span> <span class="o">/</span> <span class="n">Integer</span><span class="p">(</span><span class="n">H0</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1">#  Initial computations:</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Computing the finite products for p &lt; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">big_p</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; ... &quot;</span><span class="p">)</span>
    <span class="c1">#  Empty initial products are allowed:</span>
    <span class="c1">#  print([ p for p in range(2, big_p)])</span>
    <span class="c1">#  print([F(1/Integer(p)**s) for p in range(2, big_p)])</span>
    <span class="c1">#  print([H(1/Integer(p)**s) for p in range(2, big_p)])</span>
    <span class="c1">#  print([F(1/p**s)/H(1/p**s) for p in range(2, big_p)])</span>
    <span class="c1">#  print([R(F(1/p**s)/H(1/p**s)) for p in Primes()])</span>
    <span class="c1">#  prod_list = [1]</span>
    <span class="c1">#  for i in range(0, structure.nb_class):</span>
    <span class="c1">#      prod_list.append([R(F(1/Integer(p)**s) / H(1/Integer(p)**s))</span>
    <span class="c1">#                                       for p in filter(lambda w: (w in Primes())</span>
    <span class="c1">#                                       and (w%q in structure.the_Class_tuple[i]),</span>
    <span class="c1">#                                       range(2, big_p))])</span>
    <span class="c1">#  eulerProdIni = tuple(prod(flatten(prod_list)))</span>

    <span class="n">eulerProdIni</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">prod</span><span class="p">(</span><span class="n">flatten</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">R</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">Integer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">H</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">Integer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="n">s</span><span class="p">))</span>
                                           <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span> <span class="ow">in</span> <span class="n">Primes</span><span class="p">())</span>
                                                           <span class="ow">and</span> <span class="p">(</span><span class="n">w</span> <span class="o">%</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">the_Class_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                           <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">big_p</span><span class="p">))]]))</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done.&quot;</span><span class="p">)</span>

    <span class="c1">#  Compute CA(K, m, F/H):</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Computing C_A(K, m, F/H) ...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">my_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">big_m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">CAKmF_sur_H</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_CA_Km_F_sur_H</span><span class="p">(</span><span class="n">my_indices</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">list</span><span class="p">(),</span> <span class="n">H</span><span class="o">.</span><span class="n">list</span><span class="p">())</span>
    <span class="n">logZs_approx</span> <span class="o">=</span> <span class="n">vector</span><span class="p">([</span><span class="n">R</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">)</span>

    <span class="c1">#  Most of time is spent here.</span>
    <span class="c1">#  The main loop in m:</span>
    <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">my_delta</span><span class="p">,</span> <span class="n">big_m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">structure</span><span class="o">.</span><span class="n">get_gamma</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">big_p</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ind_a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ind_k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">):</span>
                <span class="n">logZs_approx</span><span class="p">[</span><span class="n">ind_a</span><span class="p">]</span> <span class="o">+=</span> <span class="n">aux</span><span class="p">[</span><span class="n">ind_k</span><span class="p">]</span> <span class="o">*</span> <span class="n">CAKmF_sur_H</span><span class="p">[</span><span class="n">ind_a</span><span class="p">,</span> <span class="n">ind_k</span><span class="p">,</span> <span class="n">mm</span><span class="p">]</span> <span class="o">/</span> <span class="n">mm</span>
    <span class="c1">#  End of the main loop in m</span>
    <span class="c1">#  We now have to complete the Euler products:</span>
    <span class="n">eulerProds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([(</span><span class="n">R</span><span class="p">(</span><span class="n">eulerProdIni</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">logZs_approx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">log_err</span><span class="p">))</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span>
                        <span class="n">R</span><span class="p">(</span><span class="n">eulerProdIni</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">logZs_approx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">log_err</span><span class="p">))</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">)])</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">):</span>
            <span class="n">nb_digits</span> <span class="o">=</span> <span class="n">nb_common_digits</span><span class="p">(</span><span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-------------------&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;For p + &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; ZZ in &quot;</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">the_Class_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;For F(x) =&quot;</span><span class="p">,</span> <span class="n">f_init</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;and H(x) =&quot;</span><span class="p">,</span> <span class="n">h_init</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;the product of F(1 / p) / H( 1 / p) is between&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;the product of F(1 / p^&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)/H(1 / p^&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;) is between&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;and&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">with_laTeX</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LaTeX format:&quot;</span><span class="p">)</span>
                <span class="n">how_many</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nb_decimals</span><span class="p">,</span> <span class="n">nb_digits</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">laTeX_for_number</span><span class="p">(</span><span class="n">eulerProds</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">how_many</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;(Obtained: &quot;</span><span class="p">,</span> <span class="n">nb_digits</span><span class="p">,</span> <span class="s2">&quot; correct decimal digits)&quot;</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">timer</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time taken: &quot;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot;seconds.&quot;</span><span class="p">)</span>
    <span class="c1">#  print my_indices</span>
    <span class="k">return</span> <span class="n">structure</span><span class="o">.</span><span class="n">the_Class_tuple</span><span class="p">,</span> <span class="n">eulerProds</span></div>



<div class="viewcode-block" id="table_performance">
<a class="viewcode-back" href="../../reference/api.html#euler_product.lattice_invariant_euler_products.table_performance">[docs]</a>
<span class="k">def</span> <span class="nf">table_performance</span><span class="p">(</span><span class="n">min_q</span><span class="p">,</span> <span class="n">max_q</span><span class="p">,</span> <span class="n">nb_decimals</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">big_p</span> <span class="o">=</span> <span class="mi">300</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The behaviour of this function is described in the attached tutorial</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``min_q`` -- int</span>
<span class="sd">        The modulus q goes through all the values in [min_q, max_q]</span>
<span class="sd">        that are not twice an odd integer.</span>

<span class="sd">    - ``max_q`` -- int</span>
<span class="sd">        [description]</span>

<span class="sd">    - ``nb_decimals`` -- int, optional</span>
<span class="sd">        Same as in get_vs, by default 100</span>

<span class="sd">    - ``big_p`` -- int, optional</span>
<span class="sd">        Same as in get_vs, by default 300</span>

<span class="sd">    EXAMPLES:</span>

<span class="sd">        sage: from euler_product.lattice_invariant_euler_products import table_performance</span>
<span class="sd">        sage: table_performance(10, 30)  # random</span>
<span class="sd">        11 102 digits for the first product</span>
<span class="sd">        12 102 digits for the first product</span>
<span class="sd">        13 102 digits for the first product</span>
<span class="sd">        15 102 digits for the first product</span>
<span class="sd">        16 102 digits for the first product</span>
<span class="sd">        17 102 digits for the first product</span>
<span class="sd">        19 102 digits for the first product</span>
<span class="sd">        20 102 digits for the first product</span>
<span class="sd">        21 102 digits for the first product</span>
<span class="sd">        23 102 digits for the first product</span>
<span class="sd">        24 102 digits for the first product</span>
<span class="sd">        25 102 digits for the first product</span>
<span class="sd">        27 102 digits for the first product</span>
<span class="sd">        28 102 digits for the first product</span>
<span class="sd">        29 102 digits for the first product</span>
<span class="sd">        11&amp; 10&amp; 2&amp; 8&amp; 4&amp; 21&amp; 4 \\</span>
<span class="sd">        12&amp; 4&amp; 1&amp; 5&amp; 4&amp; 21&amp; 1 \\</span>
<span class="sd">        13&amp; 12&amp; 2&amp; 10&amp; 6&amp; 21&amp; 5 \\</span>
<span class="sd">        15&amp; 8&amp; 1&amp; 5&amp; 6&amp; 21&amp; 2 \\</span>
<span class="sd">        16&amp; 8&amp; 1&amp; 5&amp; 6&amp; 21&amp; 2 \\</span>
<span class="sd">        17&amp; 16&amp; 1&amp; 5&amp; 5&amp; 21&amp; 4 \\</span>
<span class="sd">        19&amp; 18&amp; 2&amp; 10&amp; 6&amp; 21&amp; 8 \\</span>
<span class="sd">        20&amp; 8&amp; 1&amp; 5&amp; 6&amp; 21&amp; 2 \\</span>
<span class="sd">        21&amp; 12&amp; 2&amp; 10&amp; 8&amp; 21&amp; 6 \\</span>
<span class="sd">        23&amp; 22&amp; 2&amp; 6&amp; 4&amp; 21&amp; 6 \\</span>
<span class="sd">        24&amp; 8&amp; 1&amp; 5&amp; 8&amp; 21&amp; 2 \\</span>
<span class="sd">        25&amp; 20&amp; 2&amp; 8&amp; 6&amp; 21&amp; 8 \\</span>
<span class="sd">        27&amp; 18&amp; 2&amp; 10&amp; 6&amp; 21&amp; 8 \\</span>
<span class="sd">        28&amp; 12&amp; 2&amp; 10&amp; 8&amp; 21&amp; 6 \\</span>
<span class="sd">        29&amp; 28&amp; 2&amp; 7&amp; 6&amp; 21&amp; 9 \\</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref_time</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># approximate time is s for q = 3</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_q</span><span class="p">,</span> <span class="n">max_q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">q</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">q</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">get_vs</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nb_decimals</span><span class="p">,</span> <span class="n">big_p</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; digits for the first product</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">aux</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span> <span class="o">/</span> <span class="n">ref_time</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="n">res</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">=</span> <span class="n">aux</span>

    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_q</span><span class="p">,</span> <span class="n">max_q</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">str_res</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&amp; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">str_res</span> <span class="o">=</span> <span class="n">str_res</span> <span class="o">+</span> <span class="s2">&quot;&amp; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prime_divisors</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">1</span><span class="p">])))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
                <span class="n">str_res</span> <span class="o">=</span> <span class="n">str_res</span> <span class="o">+</span> <span class="s2">&quot;&amp; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">str_res</span> <span class="o">=</span> <span class="n">str_res</span> <span class="o">+</span> <span class="s2">&quot;&amp; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; </span><span class="se">\\\\</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">str_res</span><span class="p">)</span>
    <span class="k">return</span></div>



<div class="viewcode-block" id="get_vs_checker">
<a class="viewcode-back" href="../../reference/api.html#euler_product.lattice_invariant_euler_products.get_vs_checker">[docs]</a>
<span class="k">def</span> <span class="nf">get_vs_checker</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">borne</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a low level sanity check engine describe in the tutorial.</span>
<span class="sd">    It is to be used by developers only</span>

<span class="sd">    INPUT:</span>

<span class="sd">    - ``q`` -- int</span>
<span class="sd">        The products are taken over lattice invariant classes modulo q</span>

<span class="sd">    - ``s`` -- real</span>
<span class="sd">        A real number &gt; 1</span>

<span class="sd">    - ``borne`` -- int, optional</span>
<span class="sd">        boundary of computation, by default 10000</span>

<span class="sd">    EXAMPLES::</span>

<span class="sd">        sage: from euler_product.lattice_invariant_euler_products import get_vs_checker</span>
<span class="sd">        sage: get_vs_checker(8, 2)</span>
<span class="sd">        -------------------</span>
<span class="sd">        For p mod  8  in  frozenset({1})</span>
<span class="sd">        the product of 1/(1-p^{- 2 }) is about 1.0048326237351608</span>
<span class="sd">        -------------------</span>
<span class="sd">        For p mod  8  in  frozenset({3})</span>
<span class="sd">        the product of 1/(1-p^{- 2 }) is about 1.1394159722583108</span>
<span class="sd">        -------------------</span>
<span class="sd">        For p mod  8  in  frozenset({5})</span>
<span class="sd">        the product of 1/(1-p^{- 2 }) is about 1.0510974216618003</span>
<span class="sd">        -------------------</span>
<span class="sd">         For p mod  8  in  frozenset({7})</span>
<span class="sd">         the product of 1/(1-p^{- 2 }) is about 1.0251478255836493</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#  Computes an approximate value of the list (zeta(s; q, A))</span>
    <span class="c1">#  for A in the lattice-invariant classes.</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">ComponentStructure</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="c1">#  (theSGTuple, theClassTuple, nb_class, theExponent,</span>
    <span class="c1">#  phi_q, characterGroup, invertibles, invariantCharacters) = structure</span>
    <span class="n">vs_approx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="o">/</span> <span class="n">prod</span><span class="p">([</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">p</span><span class="o">**</span><span class="n">s</span>
                           <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="p">(</span><span class="n">w</span> <span class="ow">in</span> <span class="n">Primes</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">w</span> <span class="o">%</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">structure</span><span class="o">.</span><span class="n">the_Class_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                           <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">borne</span><span class="p">))])</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">nb_class</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-------------------&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;For p mod &quot;</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="s2">&quot; in &quot;</span><span class="p">,</span> <span class="n">structure</span><span class="o">.</span><span class="n">the_Class_tuple</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;the product of 1/(1-p^{-&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot;}) is about&quot;</span><span class="p">,</span> <span class="n">vs_approx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023-2024, the sage-euler-product authors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../_static/documentation_options.js?v=d45e8c67"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>